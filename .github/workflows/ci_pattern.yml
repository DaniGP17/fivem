name: CI Pattern Check

on:
  workflow_call:
    inputs:
      patterns:
        description: "Pattern list to validate (splitted by commas)"
        required: true
        type: string
      game:
        description: "Game (fivem, redm, both, none)"
        required: true
        type: string
    secrets:
      CFX_GAME_BUILDS_PASSWORD:
        required: true

permissions:
  packages: read
  contents: read
  pull-requests: write

jobs:
  pattern_check:
    name: Pre-build Pattern Check
    runs-on: ubuntu-latest
    steps:
      - name: Clone PatternV
        run: git clone --depth 1 https://github.com/DaniGP17/PatternV.git

      - name: Cache PatternV build
        uses: actions/cache@v4
        with:
          path: PatternV/build
          key: patternv-${{ hashFiles('PatternV/CMakeLists.txt') }}

      - name: Build PatternV
        run: |
          cd PatternV
          mkdir -p build && cd build
          cmake ..
          make -j$(nproc)

      - name: Download .text files
        env:
          ARCHIVE_PASSWORD: ${{ secrets.CFX_GAME_BUILDS_PASSWORD }}
        run: |
          BASE_URL="https://content.cfx.re/mirrors/client/actions-data"
          ARCHIVE_NAME="GameBuildsText.7z"

          mkdir -p Release/Builds
          cd Release/Builds

          echo "Downloading $ARCHIVE_NAME..."
          curl -sSfL --retry 3 -o "$ARCHIVE_NAME" "$BASE_URL/$ARCHIVE_NAME" || { echo "Error downloading $ARCHIVE_NAME"; exit 1; }

          echo "Calculating SHA256 of downloaded archive..."
          sha256sum "$ARCHIVE_NAME"

          echo "Extracting $ARCHIVE_NAME..."
          7z x "$ARCHIVE_NAME" -p$ARCHIVE_PASSWORD -y || { echo "Failed to extract archive"; exit 1; }

      - name: Get already commented patterns
        id: get_previous_patterns
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          result-encoding: string
          script: |
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              per_page: 100
            });

            const patternRegex = /Pattern: `([^`]+)`/g;
            const existingPatterns = new Set();

            for (const comment of comments.data) {
              console.log(`Checking comment:\n${comment.body}\n---`);
              let match;
              while ((match = patternRegex.exec(comment.body)) !== null) {
                const cleaned = match[1].trim().toLowerCase();
                console.log(`Detected pattern: '${match[1]}' => normalized: '${cleaned}'`);
                existingPatterns.add(cleaned);
              }
            }

            const result = Array.from(existingPatterns).join(',');
            console.log(`All collected patterns: ${result}`);
            return result;

      - name: Run PatternV
        id: run_patternv
        run: |
          PATTERNS_RAW="${{ inputs.patterns }}"
          ALREADY_COMMENTED="${{ steps.get_previous_patterns.outputs.result }}"
          IFS=',' read -ra ALREADY_ARRAY <<< "$ALREADY_COMMENTED"

          PATTERNS_CLEAN=$(echo "$PATTERNS_RAW" | tr ',' '\n' | sed '/^\s*$/d')

          FILTERED_PATTERNS=""
          while IFS= read -r pattern; do
            NORMALIZED=$(echo "$pattern" | tr '[:upper:]' '[:lower:]' | sed 's/  */ /g' | xargs)
            SKIP="false"
            for already in "${ALREADY_ARRAY[@]}"; do
              NORMALIZED_ALREADY=$(echo "$already" | tr '[:upper:]' '[:lower:]' | sed 's/  */ /g' | xargs)
              if [[ "$NORMALIZED" == "$NORMALIZED_ALREADY" ]]; then
                SKIP="true"
                break
              fi
            done
            if [[ "$SKIP" == "false" ]]; then
              FILTERED_PATTERNS="${FILTERED_PATTERNS}${pattern}"$'\n'
            fi
          done <<< "$PATTERNS_CLEAN"

          mapfile -t PATTERN_LIST < <(echo "$FILTERED_PATTERNS" | sed '/^\s*$/d')
          PATTERN_COUNT=${#PATTERN_LIST[@]}

          if [[ "$PATTERN_COUNT" -eq 0 ]]; then
            echo "No new patterns to analyze"
            echo "output_b64=" >> $GITHUB_OUTPUT
            exit 0
          fi

          GAME="${{ inputs.game }}"
          OUTPUT=""
          FAIL=0

          for pattern in "${PATTERN_LIST[@]}"; do
            echo "Searching pattern: $pattern"
            RESULT=$(timeout 60s ./PatternV/build/PatternV Release/Builds "$pattern" --no-color --hide-time --minified 2>&1 | tr '\r' '\n') || FAIL=2

            GTA5_MATCHES=""
            RDR2_MATCHES=""
            HAS_MISSING="false"

            while IFS= read -r line; do
              if [[ "$line" =~ GTA5_([0-9]+) ]]; then
                BUILD="${BASH_REMATCH[1]}"
                if [[ "$line" =~ \(0\ matches\) ]]; then
                  GTA5_MATCHES="$GTA5_MATCHES\n* $BUILD: ‚ùå"
                  HAS_MISSING="true"
                elif [[ "$PATTERN_COUNT" -le 3 ]]; then
                  ADDRS=$(echo "$line" | sed -E 's/.*: //')
                  IFS=',' read -ra ADDR_LIST <<< "$ADDRS"
                  GTA5_MATCHES="$GTA5_MATCHES\n* $BUILD: ${ADDR_LIST[0]^^}"
                fi
              elif [[ "$line" =~ RDR2_([0-9]+) ]]; then
                BUILD="${BASH_REMATCH[1]}"
                if [[ "$line" =~ \(0\ matches\) ]]; then
                  RDR2_MATCHES="$RDR2_MATCHES\n* $BUILD: ‚ùå"
                  HAS_MISSING="true"
                elif [[ "$PATTERN_COUNT" -le 3 ]]; then
                  ADDRS=$(echo "$line" | sed -E 's/.*: //')
                  IFS=',' read -ra ADDR_LIST <<< "$ADDRS"
                  RDR2_MATCHES="$RDR2_MATCHES\n* $BUILD: ${ADDR_LIST[0]^^}"
                fi
              fi
            done < <(echo "$RESULT")

            if true; then
              SECTION="Pattern: \`$pattern\`"
              if [[ "$GAME" == "fivem" || "$GAME" == "both" ]] && [[ -n "$GTA5_MATCHES" ]]; then
                SECTION="$SECTION\n\nMatches üöó:$GTA5_MATCHES"
              fi
              if [[ "$GAME" == "redm" || "$GAME" == "both" ]] && [[ -n "$RDR2_MATCHES" ]]; then
                SECTION="$SECTION\n\nMatches üêé:$RDR2_MATCHES"
              fi
              OUTPUT="$OUTPUT\n\n$SECTION\n\n---"
            fi
          done

          OUTPUT=$(echo -e "$OUTPUT" | sed '$d')

          ENCODED=$(echo -e "$OUTPUT" | base64 -w0)
          echo "output_b64=$ENCODED" >> $GITHUB_OUTPUT


      
      - name: Comment results on PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const b64 = `${{ steps.run_patternv.outputs.output_b64 }}`;
            if (!b64 || b64.trim() === "") {
              console.log("No new patterns to comment.");
              return;
            }
            const decoded = Buffer.from(b64, 'base64').toString();
            const maxLength = 65536;

            if (decoded.length <= maxLength) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: decoded
              });
            } else {
              console.log("Output too long, splitting into multiple comments...");
              const chunks = [];
              for (let i = 0; i < decoded.length; i += maxLength) {
                chunks.push(decoded.substring(i, i + maxLength));
              }

              for (let i = 0; i < chunks.length; i++) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: `**Part ${i + 1}/${chunks.length}**\n\n` + chunks[i]
                });
              }
            }